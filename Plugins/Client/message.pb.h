// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsRequestWrapperImpl();
void InitDefaultsRequestWrapper();
void InitDefaultsRespondWrapperImpl();
void InitDefaultsRespondWrapper();
void InitDefaultsRequestInfoImpl();
void InitDefaultsRequestInfo();
void InitDefaultsRespondInfoImpl();
void InitDefaultsRespondInfo();
void InitDefaultsModelImpl();
void InitDefaultsModel();
void InitDefaultsBoolOptionImpl();
void InitDefaultsBoolOption();
void InitDefaultsIntOptionImpl();
void InitDefaultsIntOption();
void InitDefaultsFloatOptionImpl();
void InitDefaultsFloatOption();
void InitDefaultsStringOptionImpl();
void InitDefaultsStringOption();
void InitDefaultsMultipleChoiceOptionImpl();
void InitDefaultsMultipleChoiceOption();
void InitDefaultsImagePrototypeImpl();
void InitDefaultsImagePrototype();
void InitDefaultsErrorImpl();
void InitDefaultsError();
void InitDefaultsRequestInferenceImpl();
void InitDefaultsRequestInference();
void InitDefaultsRespondInferenceImpl();
void InitDefaultsRespondInference();
void InitDefaultsImageImpl();
void InitDefaultsImage();
inline void InitDefaults() {
  InitDefaultsRequestWrapper();
  InitDefaultsRespondWrapper();
  InitDefaultsRequestInfo();
  InitDefaultsRespondInfo();
  InitDefaultsModel();
  InitDefaultsBoolOption();
  InitDefaultsIntOption();
  InitDefaultsFloatOption();
  InitDefaultsStringOption();
  InitDefaultsMultipleChoiceOption();
  InitDefaultsImagePrototype();
  InitDefaultsError();
  InitDefaultsRequestInference();
  InitDefaultsRespondInference();
  InitDefaultsImage();
}
}  // namespace protobuf_message_2eproto
namespace dlserver {
class BoolOption;
class BoolOptionDefaultTypeInternal;
extern BoolOptionDefaultTypeInternal _BoolOption_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class FloatOption;
class FloatOptionDefaultTypeInternal;
extern FloatOptionDefaultTypeInternal _FloatOption_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImagePrototype;
class ImagePrototypeDefaultTypeInternal;
extern ImagePrototypeDefaultTypeInternal _ImagePrototype_default_instance_;
class IntOption;
class IntOptionDefaultTypeInternal;
extern IntOptionDefaultTypeInternal _IntOption_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class MultipleChoiceOption;
class MultipleChoiceOptionDefaultTypeInternal;
extern MultipleChoiceOptionDefaultTypeInternal _MultipleChoiceOption_default_instance_;
class RequestInference;
class RequestInferenceDefaultTypeInternal;
extern RequestInferenceDefaultTypeInternal _RequestInference_default_instance_;
class RequestInfo;
class RequestInfoDefaultTypeInternal;
extern RequestInfoDefaultTypeInternal _RequestInfo_default_instance_;
class RequestWrapper;
class RequestWrapperDefaultTypeInternal;
extern RequestWrapperDefaultTypeInternal _RequestWrapper_default_instance_;
class RespondInference;
class RespondInferenceDefaultTypeInternal;
extern RespondInferenceDefaultTypeInternal _RespondInference_default_instance_;
class RespondInfo;
class RespondInfoDefaultTypeInternal;
extern RespondInfoDefaultTypeInternal _RespondInfo_default_instance_;
class RespondWrapper;
class RespondWrapperDefaultTypeInternal;
extern RespondWrapperDefaultTypeInternal _RespondWrapper_default_instance_;
class StringOption;
class StringOptionDefaultTypeInternal;
extern StringOptionDefaultTypeInternal _StringOption_default_instance_;
}  // namespace dlserver
namespace dlserver {

// ===================================================================

class RequestWrapper : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.RequestWrapper) */ {
 public:
  RequestWrapper();
  virtual ~RequestWrapper();

  RequestWrapper(const RequestWrapper& from);

  inline RequestWrapper& operator=(const RequestWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestWrapper(RequestWrapper&& from) noexcept
    : RequestWrapper() {
    *this = ::std::move(from);
  }

  inline RequestWrapper& operator=(RequestWrapper&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestWrapper& default_instance();

  enum RequestCase {
    kR1 = 2,
    kR2 = 3,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestWrapper* internal_default_instance() {
    return reinterpret_cast<const RequestWrapper*>(
               &_RequestWrapper_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RequestWrapper* other);
  friend void swap(RequestWrapper& a, RequestWrapper& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestWrapper* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestWrapper* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestWrapper& from);
  void MergeFrom(const RequestWrapper& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestWrapper* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  bool info() const;
  void set_info(bool value);

  // optional .dlserver.RequestInfo r1 = 2;
  bool has_r1() const;
  void clear_r1();
  static const int kR1FieldNumber = 2;
  const ::dlserver::RequestInfo& r1() const;
  ::dlserver::RequestInfo* release_r1();
  ::dlserver::RequestInfo* mutable_r1();
  void set_allocated_r1(::dlserver::RequestInfo* r1);

  // optional .dlserver.RequestInference r2 = 3;
  bool has_r2() const;
  void clear_r2();
  static const int kR2FieldNumber = 3;
  const ::dlserver::RequestInference& r2() const;
  ::dlserver::RequestInference* release_r2();
  ::dlserver::RequestInference* mutable_r2();
  void set_allocated_r2(::dlserver::RequestInference* r2);

  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:dlserver.RequestWrapper)
 private:
  void set_has_info();
  void clear_has_info();
  void set_has_r1();
  void set_has_r2();

  inline bool has_request() const;
  void clear_request();
  inline void clear_has_request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool info_;
  union RequestUnion {
    RequestUnion() {}
    ::dlserver::RequestInfo* r1_;
    ::dlserver::RequestInference* r2_;
  } request_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRequestWrapperImpl();
};
// -------------------------------------------------------------------

class RespondWrapper : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.RespondWrapper) */ {
 public:
  RespondWrapper();
  virtual ~RespondWrapper();

  RespondWrapper(const RespondWrapper& from);

  inline RespondWrapper& operator=(const RespondWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespondWrapper(RespondWrapper&& from) noexcept
    : RespondWrapper() {
    *this = ::std::move(from);
  }

  inline RespondWrapper& operator=(RespondWrapper&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondWrapper& default_instance();

  enum ResponseCase {
    kR1 = 2,
    kR2 = 3,
    RESPONSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespondWrapper* internal_default_instance() {
    return reinterpret_cast<const RespondWrapper*>(
               &_RespondWrapper_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RespondWrapper* other);
  friend void swap(RespondWrapper& a, RespondWrapper& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespondWrapper* New() const PROTOBUF_FINAL { return New(NULL); }

  RespondWrapper* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RespondWrapper& from);
  void MergeFrom(const RespondWrapper& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RespondWrapper* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  bool info() const;
  void set_info(bool value);

  // optional .dlserver.RespondInfo r1 = 2;
  bool has_r1() const;
  void clear_r1();
  static const int kR1FieldNumber = 2;
  const ::dlserver::RespondInfo& r1() const;
  ::dlserver::RespondInfo* release_r1();
  ::dlserver::RespondInfo* mutable_r1();
  void set_allocated_r1(::dlserver::RespondInfo* r1);

  // optional .dlserver.RespondInference r2 = 3;
  bool has_r2() const;
  void clear_r2();
  static const int kR2FieldNumber = 3;
  const ::dlserver::RespondInference& r2() const;
  ::dlserver::RespondInference* release_r2();
  ::dlserver::RespondInference* mutable_r2();
  void set_allocated_r2(::dlserver::RespondInference* r2);

  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:dlserver.RespondWrapper)
 private:
  void set_has_info();
  void clear_has_info();
  void set_has_r1();
  void set_has_r2();

  inline bool has_response() const;
  void clear_response();
  inline void clear_has_response();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool info_;
  union ResponseUnion {
    ResponseUnion() {}
    ::dlserver::RespondInfo* r1_;
    ::dlserver::RespondInference* r2_;
  } response_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRespondWrapperImpl();
};
// -------------------------------------------------------------------

class RequestInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.RequestInfo) */ {
 public:
  RequestInfo();
  virtual ~RequestInfo();

  RequestInfo(const RequestInfo& from);

  inline RequestInfo& operator=(const RequestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestInfo(RequestInfo&& from) noexcept
    : RequestInfo() {
    *this = ::std::move(from);
  }

  inline RequestInfo& operator=(RequestInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestInfo* internal_default_instance() {
    return reinterpret_cast<const RequestInfo*>(
               &_RequestInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RequestInfo* other);
  friend void swap(RequestInfo& a, RequestInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestInfo& from);
  void MergeFrom(const RequestInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  bool info() const;
  void set_info(bool value);

  // @@protoc_insertion_point(class_scope:dlserver.RequestInfo)
 private:
  void set_has_info();
  void clear_has_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool info_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRequestInfoImpl();
};
// -------------------------------------------------------------------

class RespondInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.RespondInfo) */ {
 public:
  RespondInfo();
  virtual ~RespondInfo();

  RespondInfo(const RespondInfo& from);

  inline RespondInfo& operator=(const RespondInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespondInfo(RespondInfo&& from) noexcept
    : RespondInfo() {
    *this = ::std::move(from);
  }

  inline RespondInfo& operator=(RespondInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespondInfo* internal_default_instance() {
    return reinterpret_cast<const RespondInfo*>(
               &_RespondInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RespondInfo* other);
  friend void swap(RespondInfo& a, RespondInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespondInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RespondInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RespondInfo& from);
  void MergeFrom(const RespondInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RespondInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dlserver.Model models = 2;
  int models_size() const;
  void clear_models();
  static const int kModelsFieldNumber = 2;
  const ::dlserver::Model& models(int index) const;
  ::dlserver::Model* mutable_models(int index);
  ::dlserver::Model* add_models();
  ::google::protobuf::RepeatedPtrField< ::dlserver::Model >*
      mutable_models();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::Model >&
      models() const;

  // required int32 numModels = 1;
  bool has_nummodels() const;
  void clear_nummodels();
  static const int kNumModelsFieldNumber = 1;
  ::google::protobuf::int32 nummodels() const;
  void set_nummodels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dlserver.RespondInfo)
 private:
  void set_has_nummodels();
  void clear_has_nummodels();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::Model > models_;
  ::google::protobuf::int32 nummodels_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRespondInfoImpl();
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const PROTOBUF_FINAL { return New(NULL); }

  Model* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dlserver.ImagePrototype inputs = 3;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 3;
  const ::dlserver::ImagePrototype& inputs(int index) const;
  ::dlserver::ImagePrototype* mutable_inputs(int index);
  ::dlserver::ImagePrototype* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >&
      inputs() const;

  // repeated .dlserver.ImagePrototype outputs = 4;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 4;
  const ::dlserver::ImagePrototype& outputs(int index) const;
  ::dlserver::ImagePrototype* mutable_outputs(int index);
  ::dlserver::ImagePrototype* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >&
      outputs() const;

  // repeated .dlserver.BoolOption boolOptions = 5;
  int booloptions_size() const;
  void clear_booloptions();
  static const int kBoolOptionsFieldNumber = 5;
  const ::dlserver::BoolOption& booloptions(int index) const;
  ::dlserver::BoolOption* mutable_booloptions(int index);
  ::dlserver::BoolOption* add_booloptions();
  ::google::protobuf::RepeatedPtrField< ::dlserver::BoolOption >*
      mutable_booloptions();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::BoolOption >&
      booloptions() const;

  // repeated .dlserver.IntOption intOptions = 6;
  int intoptions_size() const;
  void clear_intoptions();
  static const int kIntOptionsFieldNumber = 6;
  const ::dlserver::IntOption& intoptions(int index) const;
  ::dlserver::IntOption* mutable_intoptions(int index);
  ::dlserver::IntOption* add_intoptions();
  ::google::protobuf::RepeatedPtrField< ::dlserver::IntOption >*
      mutable_intoptions();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::IntOption >&
      intoptions() const;

  // repeated .dlserver.FloatOption floatOptions = 7;
  int floatoptions_size() const;
  void clear_floatoptions();
  static const int kFloatOptionsFieldNumber = 7;
  const ::dlserver::FloatOption& floatoptions(int index) const;
  ::dlserver::FloatOption* mutable_floatoptions(int index);
  ::dlserver::FloatOption* add_floatoptions();
  ::google::protobuf::RepeatedPtrField< ::dlserver::FloatOption >*
      mutable_floatoptions();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::FloatOption >&
      floatoptions() const;

  // repeated .dlserver.StringOption stringOptions = 8;
  int stringoptions_size() const;
  void clear_stringoptions();
  static const int kStringOptionsFieldNumber = 8;
  const ::dlserver::StringOption& stringoptions(int index) const;
  ::dlserver::StringOption* mutable_stringoptions(int index);
  ::dlserver::StringOption* add_stringoptions();
  ::google::protobuf::RepeatedPtrField< ::dlserver::StringOption >*
      mutable_stringoptions();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::StringOption >&
      stringoptions() const;

  // repeated .dlserver.MultipleChoiceOption mcOptions = 9;
  int mcoptions_size() const;
  void clear_mcoptions();
  static const int kMcOptionsFieldNumber = 9;
  const ::dlserver::MultipleChoiceOption& mcoptions(int index) const;
  ::dlserver::MultipleChoiceOption* mutable_mcoptions(int index);
  ::dlserver::MultipleChoiceOption* add_mcoptions();
  ::google::protobuf::RepeatedPtrField< ::dlserver::MultipleChoiceOption >*
      mutable_mcoptions();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::MultipleChoiceOption >&
      mcoptions() const;

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:dlserver.Model)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_label();
  void clear_has_label();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype > inputs_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype > outputs_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::BoolOption > booloptions_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::IntOption > intoptions_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::FloatOption > floatoptions_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::StringOption > stringoptions_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::MultipleChoiceOption > mcoptions_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsModelImpl();
};
// -------------------------------------------------------------------

class BoolOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.BoolOption) */ {
 public:
  BoolOption();
  virtual ~BoolOption();

  BoolOption(const BoolOption& from);

  inline BoolOption& operator=(const BoolOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BoolOption(BoolOption&& from) noexcept
    : BoolOption() {
    *this = ::std::move(from);
  }

  inline BoolOption& operator=(BoolOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoolOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoolOption* internal_default_instance() {
    return reinterpret_cast<const BoolOption*>(
               &_BoolOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(BoolOption* other);
  friend void swap(BoolOption& a, BoolOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BoolOption* New() const PROTOBUF_FINAL { return New(NULL); }

  BoolOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BoolOption& from);
  void MergeFrom(const BoolOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BoolOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required bool value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  bool value() const;
  void set_value(bool value);

  // @@protoc_insertion_point(class_scope:dlserver.BoolOption)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool value_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsBoolOptionImpl();
};
// -------------------------------------------------------------------

class IntOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.IntOption) */ {
 public:
  IntOption();
  virtual ~IntOption();

  IntOption(const IntOption& from);

  inline IntOption& operator=(const IntOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntOption(IntOption&& from) noexcept
    : IntOption() {
    *this = ::std::move(from);
  }

  inline IntOption& operator=(IntOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntOption* internal_default_instance() {
    return reinterpret_cast<const IntOption*>(
               &_IntOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(IntOption* other);
  friend void swap(IntOption& a, IntOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntOption* New() const PROTOBUF_FINAL { return New(NULL); }

  IntOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IntOption& from);
  void MergeFrom(const IntOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IntOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dlserver.IntOption)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 value_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsIntOptionImpl();
};
// -------------------------------------------------------------------

class FloatOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.FloatOption) */ {
 public:
  FloatOption();
  virtual ~FloatOption();

  FloatOption(const FloatOption& from);

  inline FloatOption& operator=(const FloatOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatOption(FloatOption&& from) noexcept
    : FloatOption() {
    *this = ::std::move(from);
  }

  inline FloatOption& operator=(FloatOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatOption* internal_default_instance() {
    return reinterpret_cast<const FloatOption*>(
               &_FloatOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(FloatOption* other);
  friend void swap(FloatOption& a, FloatOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatOption* New() const PROTOBUF_FINAL { return New(NULL); }

  FloatOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FloatOption& from);
  void MergeFrom(const FloatOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FloatOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:dlserver.FloatOption)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  float value_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsFloatOptionImpl();
};
// -------------------------------------------------------------------

class StringOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.StringOption) */ {
 public:
  StringOption();
  virtual ~StringOption();

  StringOption(const StringOption& from);

  inline StringOption& operator=(const StringOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringOption(StringOption&& from) noexcept
    : StringOption() {
    *this = ::std::move(from);
  }

  inline StringOption& operator=(StringOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringOption* internal_default_instance() {
    return reinterpret_cast<const StringOption*>(
               &_StringOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(StringOption* other);
  friend void swap(StringOption& a, StringOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringOption* New() const PROTOBUF_FINAL { return New(NULL); }

  StringOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StringOption& from);
  void MergeFrom(const StringOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StringOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:dlserver.StringOption)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsStringOptionImpl();
};
// -------------------------------------------------------------------

class MultipleChoiceOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.MultipleChoiceOption) */ {
 public:
  MultipleChoiceOption();
  virtual ~MultipleChoiceOption();

  MultipleChoiceOption(const MultipleChoiceOption& from);

  inline MultipleChoiceOption& operator=(const MultipleChoiceOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultipleChoiceOption(MultipleChoiceOption&& from) noexcept
    : MultipleChoiceOption() {
    *this = ::std::move(from);
  }

  inline MultipleChoiceOption& operator=(MultipleChoiceOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultipleChoiceOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultipleChoiceOption* internal_default_instance() {
    return reinterpret_cast<const MultipleChoiceOption*>(
               &_MultipleChoiceOption_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(MultipleChoiceOption* other);
  friend void swap(MultipleChoiceOption& a, MultipleChoiceOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultipleChoiceOption* New() const PROTOBUF_FINAL { return New(NULL); }

  MultipleChoiceOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MultipleChoiceOption& from);
  void MergeFrom(const MultipleChoiceOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MultipleChoiceOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string choices = 3;
  int choices_size() const;
  void clear_choices();
  static const int kChoicesFieldNumber = 3;
  const ::std::string& choices(int index) const;
  ::std::string* mutable_choices(int index);
  void set_choices(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_choices(int index, ::std::string&& value);
  #endif
  void set_choices(int index, const char* value);
  void set_choices(int index, const char* value, size_t size);
  ::std::string* add_choices();
  void add_choices(const ::std::string& value);
  #if LANG_CXX11
  void add_choices(::std::string&& value);
  #endif
  void add_choices(const char* value);
  void add_choices(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& choices() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_choices();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:dlserver.MultipleChoiceOption)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> choices_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsMultipleChoiceOptionImpl();
};
// -------------------------------------------------------------------

class ImagePrototype : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.ImagePrototype) */ {
 public:
  ImagePrototype();
  virtual ~ImagePrototype();

  ImagePrototype(const ImagePrototype& from);

  inline ImagePrototype& operator=(const ImagePrototype& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImagePrototype(ImagePrototype&& from) noexcept
    : ImagePrototype() {
    *this = ::std::move(from);
  }

  inline ImagePrototype& operator=(ImagePrototype&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImagePrototype& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImagePrototype* internal_default_instance() {
    return reinterpret_cast<const ImagePrototype*>(
               &_ImagePrototype_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ImagePrototype* other);
  friend void swap(ImagePrototype& a, ImagePrototype& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImagePrototype* New() const PROTOBUF_FINAL { return New(NULL); }

  ImagePrototype* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ImagePrototype& from);
  void MergeFrom(const ImagePrototype& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ImagePrototype* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 channels = 2;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 2;
  ::google::protobuf::int32 channels() const;
  void set_channels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dlserver.ImagePrototype)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_channels();
  void clear_has_channels();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 channels_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsImagePrototypeImpl();
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg = 1;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 1;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:dlserver.Error)
 private:
  void set_has_msg();
  void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsErrorImpl();
};
// -------------------------------------------------------------------

class RequestInference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.RequestInference) */ {
 public:
  RequestInference();
  virtual ~RequestInference();

  RequestInference(const RequestInference& from);

  inline RequestInference& operator=(const RequestInference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestInference(RequestInference&& from) noexcept
    : RequestInference() {
    *this = ::std::move(from);
  }

  inline RequestInference& operator=(RequestInference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestInference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestInference* internal_default_instance() {
    return reinterpret_cast<const RequestInference*>(
               &_RequestInference_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(RequestInference* other);
  friend void swap(RequestInference& a, RequestInference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestInference* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestInference* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestInference& from);
  void MergeFrom(const RequestInference& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestInference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dlserver.Image image = 2;
  int image_size() const;
  void clear_image();
  static const int kImageFieldNumber = 2;
  const ::dlserver::Image& image(int index) const;
  ::dlserver::Image* mutable_image(int index);
  ::dlserver::Image* add_image();
  ::google::protobuf::RepeatedPtrField< ::dlserver::Image >*
      mutable_image();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::Image >&
      image() const;

  // required .dlserver.Model model = 1;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::dlserver::Model& model() const;
  ::dlserver::Model* release_model();
  ::dlserver::Model* mutable_model();
  void set_allocated_model(::dlserver::Model* model);

  // @@protoc_insertion_point(class_scope:dlserver.RequestInference)
 private:
  void set_has_model();
  void clear_has_model();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::Image > image_;
  ::dlserver::Model* model_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRequestInferenceImpl();
};
// -------------------------------------------------------------------

class RespondInference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.RespondInference) */ {
 public:
  RespondInference();
  virtual ~RespondInference();

  RespondInference(const RespondInference& from);

  inline RespondInference& operator=(const RespondInference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespondInference(RespondInference&& from) noexcept
    : RespondInference() {
    *this = ::std::move(from);
  }

  inline RespondInference& operator=(RespondInference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespondInference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespondInference* internal_default_instance() {
    return reinterpret_cast<const RespondInference*>(
               &_RespondInference_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(RespondInference* other);
  friend void swap(RespondInference& a, RespondInference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespondInference* New() const PROTOBUF_FINAL { return New(NULL); }

  RespondInference* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RespondInference& from);
  void MergeFrom(const RespondInference& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RespondInference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .dlserver.Image image = 2;
  int image_size() const;
  void clear_image();
  static const int kImageFieldNumber = 2;
  const ::dlserver::Image& image(int index) const;
  ::dlserver::Image* mutable_image(int index);
  ::dlserver::Image* add_image();
  ::google::protobuf::RepeatedPtrField< ::dlserver::Image >*
      mutable_image();
  const ::google::protobuf::RepeatedPtrField< ::dlserver::Image >&
      image() const;

  // required int32 numImages = 1;
  bool has_numimages() const;
  void clear_numimages();
  static const int kNumImagesFieldNumber = 1;
  ::google::protobuf::int32 numimages() const;
  void set_numimages(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dlserver.RespondInference)
 private:
  void set_has_numimages();
  void clear_has_numimages();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::dlserver::Image > image_;
  ::google::protobuf::int32 numimages_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRespondInferenceImpl();
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:dlserver.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const PROTOBUF_FINAL { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes image = 4;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 4;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // required int32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // required int32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // required int32 channels = 3;
  bool has_channels() const;
  void clear_channels();
  static const int kChannelsFieldNumber = 3;
  ::google::protobuf::int32 channels() const;
  void set_channels(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:dlserver.Image)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_channels();
  void clear_has_channels();
  void set_has_image();
  void clear_has_image();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 channels_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsImageImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestWrapper

// required bool info = 1;
inline bool RequestWrapper::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestWrapper::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestWrapper::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestWrapper::clear_info() {
  info_ = false;
  clear_has_info();
}
inline bool RequestWrapper::info() const {
  // @@protoc_insertion_point(field_get:dlserver.RequestWrapper.info)
  return info_;
}
inline void RequestWrapper::set_info(bool value) {
  set_has_info();
  info_ = value;
  // @@protoc_insertion_point(field_set:dlserver.RequestWrapper.info)
}

// optional .dlserver.RequestInfo r1 = 2;
inline bool RequestWrapper::has_r1() const {
  return request_case() == kR1;
}
inline void RequestWrapper::set_has_r1() {
  _oneof_case_[0] = kR1;
}
inline void RequestWrapper::clear_r1() {
  if (has_r1()) {
    delete request_.r1_;
    clear_has_request();
  }
}
inline ::dlserver::RequestInfo* RequestWrapper::release_r1() {
  // @@protoc_insertion_point(field_release:dlserver.RequestWrapper.r1)
  if (has_r1()) {
    clear_has_request();
      ::dlserver::RequestInfo* temp = request_.r1_;
    request_.r1_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dlserver::RequestInfo& RequestWrapper::r1() const {
  // @@protoc_insertion_point(field_get:dlserver.RequestWrapper.r1)
  return has_r1()
      ? *request_.r1_
      : *reinterpret_cast< ::dlserver::RequestInfo*>(&::dlserver::_RequestInfo_default_instance_);
}
inline ::dlserver::RequestInfo* RequestWrapper::mutable_r1() {
  if (!has_r1()) {
    clear_request();
    set_has_r1();
    request_.r1_ = new ::dlserver::RequestInfo;
  }
  // @@protoc_insertion_point(field_mutable:dlserver.RequestWrapper.r1)
  return request_.r1_;
}

// optional .dlserver.RequestInference r2 = 3;
inline bool RequestWrapper::has_r2() const {
  return request_case() == kR2;
}
inline void RequestWrapper::set_has_r2() {
  _oneof_case_[0] = kR2;
}
inline void RequestWrapper::clear_r2() {
  if (has_r2()) {
    delete request_.r2_;
    clear_has_request();
  }
}
inline ::dlserver::RequestInference* RequestWrapper::release_r2() {
  // @@protoc_insertion_point(field_release:dlserver.RequestWrapper.r2)
  if (has_r2()) {
    clear_has_request();
      ::dlserver::RequestInference* temp = request_.r2_;
    request_.r2_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dlserver::RequestInference& RequestWrapper::r2() const {
  // @@protoc_insertion_point(field_get:dlserver.RequestWrapper.r2)
  return has_r2()
      ? *request_.r2_
      : *reinterpret_cast< ::dlserver::RequestInference*>(&::dlserver::_RequestInference_default_instance_);
}
inline ::dlserver::RequestInference* RequestWrapper::mutable_r2() {
  if (!has_r2()) {
    clear_request();
    set_has_r2();
    request_.r2_ = new ::dlserver::RequestInference;
  }
  // @@protoc_insertion_point(field_mutable:dlserver.RequestWrapper.r2)
  return request_.r2_;
}

inline bool RequestWrapper::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void RequestWrapper::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline RequestWrapper::RequestCase RequestWrapper::request_case() const {
  return RequestWrapper::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RespondWrapper

// required bool info = 1;
inline bool RespondWrapper::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondWrapper::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondWrapper::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondWrapper::clear_info() {
  info_ = false;
  clear_has_info();
}
inline bool RespondWrapper::info() const {
  // @@protoc_insertion_point(field_get:dlserver.RespondWrapper.info)
  return info_;
}
inline void RespondWrapper::set_info(bool value) {
  set_has_info();
  info_ = value;
  // @@protoc_insertion_point(field_set:dlserver.RespondWrapper.info)
}

// optional .dlserver.RespondInfo r1 = 2;
inline bool RespondWrapper::has_r1() const {
  return response_case() == kR1;
}
inline void RespondWrapper::set_has_r1() {
  _oneof_case_[0] = kR1;
}
inline void RespondWrapper::clear_r1() {
  if (has_r1()) {
    delete response_.r1_;
    clear_has_response();
  }
}
inline ::dlserver::RespondInfo* RespondWrapper::release_r1() {
  // @@protoc_insertion_point(field_release:dlserver.RespondWrapper.r1)
  if (has_r1()) {
    clear_has_response();
      ::dlserver::RespondInfo* temp = response_.r1_;
    response_.r1_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dlserver::RespondInfo& RespondWrapper::r1() const {
  // @@protoc_insertion_point(field_get:dlserver.RespondWrapper.r1)
  return has_r1()
      ? *response_.r1_
      : *reinterpret_cast< ::dlserver::RespondInfo*>(&::dlserver::_RespondInfo_default_instance_);
}
inline ::dlserver::RespondInfo* RespondWrapper::mutable_r1() {
  if (!has_r1()) {
    clear_response();
    set_has_r1();
    response_.r1_ = new ::dlserver::RespondInfo;
  }
  // @@protoc_insertion_point(field_mutable:dlserver.RespondWrapper.r1)
  return response_.r1_;
}

// optional .dlserver.RespondInference r2 = 3;
inline bool RespondWrapper::has_r2() const {
  return response_case() == kR2;
}
inline void RespondWrapper::set_has_r2() {
  _oneof_case_[0] = kR2;
}
inline void RespondWrapper::clear_r2() {
  if (has_r2()) {
    delete response_.r2_;
    clear_has_response();
  }
}
inline ::dlserver::RespondInference* RespondWrapper::release_r2() {
  // @@protoc_insertion_point(field_release:dlserver.RespondWrapper.r2)
  if (has_r2()) {
    clear_has_response();
      ::dlserver::RespondInference* temp = response_.r2_;
    response_.r2_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dlserver::RespondInference& RespondWrapper::r2() const {
  // @@protoc_insertion_point(field_get:dlserver.RespondWrapper.r2)
  return has_r2()
      ? *response_.r2_
      : *reinterpret_cast< ::dlserver::RespondInference*>(&::dlserver::_RespondInference_default_instance_);
}
inline ::dlserver::RespondInference* RespondWrapper::mutable_r2() {
  if (!has_r2()) {
    clear_response();
    set_has_r2();
    response_.r2_ = new ::dlserver::RespondInference;
  }
  // @@protoc_insertion_point(field_mutable:dlserver.RespondWrapper.r2)
  return response_.r2_;
}

inline bool RespondWrapper::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void RespondWrapper::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline RespondWrapper::ResponseCase RespondWrapper::response_case() const {
  return RespondWrapper::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestInfo

// required bool info = 1;
inline bool RequestInfo::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestInfo::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestInfo::clear_info() {
  info_ = false;
  clear_has_info();
}
inline bool RequestInfo::info() const {
  // @@protoc_insertion_point(field_get:dlserver.RequestInfo.info)
  return info_;
}
inline void RequestInfo::set_info(bool value) {
  set_has_info();
  info_ = value;
  // @@protoc_insertion_point(field_set:dlserver.RequestInfo.info)
}

// -------------------------------------------------------------------

// RespondInfo

// required int32 numModels = 1;
inline bool RespondInfo::has_nummodels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondInfo::set_has_nummodels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondInfo::clear_has_nummodels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondInfo::clear_nummodels() {
  nummodels_ = 0;
  clear_has_nummodels();
}
inline ::google::protobuf::int32 RespondInfo::nummodels() const {
  // @@protoc_insertion_point(field_get:dlserver.RespondInfo.numModels)
  return nummodels_;
}
inline void RespondInfo::set_nummodels(::google::protobuf::int32 value) {
  set_has_nummodels();
  nummodels_ = value;
  // @@protoc_insertion_point(field_set:dlserver.RespondInfo.numModels)
}

// repeated .dlserver.Model models = 2;
inline int RespondInfo::models_size() const {
  return models_.size();
}
inline void RespondInfo::clear_models() {
  models_.Clear();
}
inline const ::dlserver::Model& RespondInfo::models(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.RespondInfo.models)
  return models_.Get(index);
}
inline ::dlserver::Model* RespondInfo::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.RespondInfo.models)
  return models_.Mutable(index);
}
inline ::dlserver::Model* RespondInfo::add_models() {
  // @@protoc_insertion_point(field_add:dlserver.RespondInfo.models)
  return models_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::Model >*
RespondInfo::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.RespondInfo.models)
  return &models_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::Model >&
RespondInfo::models() const {
  // @@protoc_insertion_point(field_list:dlserver.RespondInfo.models)
  return models_;
}

// -------------------------------------------------------------------

// Model

// required string name = 1;
inline bool Model::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Model::name() const {
  // @@protoc_insertion_point(field_get:dlserver.Model.name)
  return name_.GetNoArena();
}
inline void Model::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.Model.name)
}
#if LANG_CXX11
inline void Model::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.Model.name)
}
#endif
inline void Model::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.Model.name)
}
inline void Model::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.Model.name)
}
inline ::std::string* Model::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dlserver.Model.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model::release_name() {
  // @@protoc_insertion_point(field_release:dlserver.Model.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dlserver.Model.name)
}

// required string label = 2;
inline bool Model::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Model::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Model::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Model::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& Model::label() const {
  // @@protoc_insertion_point(field_get:dlserver.Model.label)
  return label_.GetNoArena();
}
inline void Model::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.Model.label)
}
#if LANG_CXX11
inline void Model::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.Model.label)
}
#endif
inline void Model::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.Model.label)
}
inline void Model::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.Model.label)
}
inline ::std::string* Model::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:dlserver.Model.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model::release_label() {
  // @@protoc_insertion_point(field_release:dlserver.Model.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:dlserver.Model.label)
}

// repeated .dlserver.ImagePrototype inputs = 3;
inline int Model::inputs_size() const {
  return inputs_.size();
}
inline void Model::clear_inputs() {
  inputs_.Clear();
}
inline const ::dlserver::ImagePrototype& Model::inputs(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.Model.inputs)
  return inputs_.Get(index);
}
inline ::dlserver::ImagePrototype* Model::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.Model.inputs)
  return inputs_.Mutable(index);
}
inline ::dlserver::ImagePrototype* Model::add_inputs() {
  // @@protoc_insertion_point(field_add:dlserver.Model.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >*
Model::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.Model.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >&
Model::inputs() const {
  // @@protoc_insertion_point(field_list:dlserver.Model.inputs)
  return inputs_;
}

// repeated .dlserver.ImagePrototype outputs = 4;
inline int Model::outputs_size() const {
  return outputs_.size();
}
inline void Model::clear_outputs() {
  outputs_.Clear();
}
inline const ::dlserver::ImagePrototype& Model::outputs(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.Model.outputs)
  return outputs_.Get(index);
}
inline ::dlserver::ImagePrototype* Model::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.Model.outputs)
  return outputs_.Mutable(index);
}
inline ::dlserver::ImagePrototype* Model::add_outputs() {
  // @@protoc_insertion_point(field_add:dlserver.Model.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >*
Model::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.Model.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::ImagePrototype >&
Model::outputs() const {
  // @@protoc_insertion_point(field_list:dlserver.Model.outputs)
  return outputs_;
}

// repeated .dlserver.BoolOption boolOptions = 5;
inline int Model::booloptions_size() const {
  return booloptions_.size();
}
inline void Model::clear_booloptions() {
  booloptions_.Clear();
}
inline const ::dlserver::BoolOption& Model::booloptions(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.Model.boolOptions)
  return booloptions_.Get(index);
}
inline ::dlserver::BoolOption* Model::mutable_booloptions(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.Model.boolOptions)
  return booloptions_.Mutable(index);
}
inline ::dlserver::BoolOption* Model::add_booloptions() {
  // @@protoc_insertion_point(field_add:dlserver.Model.boolOptions)
  return booloptions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::BoolOption >*
Model::mutable_booloptions() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.Model.boolOptions)
  return &booloptions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::BoolOption >&
Model::booloptions() const {
  // @@protoc_insertion_point(field_list:dlserver.Model.boolOptions)
  return booloptions_;
}

// repeated .dlserver.IntOption intOptions = 6;
inline int Model::intoptions_size() const {
  return intoptions_.size();
}
inline void Model::clear_intoptions() {
  intoptions_.Clear();
}
inline const ::dlserver::IntOption& Model::intoptions(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.Model.intOptions)
  return intoptions_.Get(index);
}
inline ::dlserver::IntOption* Model::mutable_intoptions(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.Model.intOptions)
  return intoptions_.Mutable(index);
}
inline ::dlserver::IntOption* Model::add_intoptions() {
  // @@protoc_insertion_point(field_add:dlserver.Model.intOptions)
  return intoptions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::IntOption >*
Model::mutable_intoptions() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.Model.intOptions)
  return &intoptions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::IntOption >&
Model::intoptions() const {
  // @@protoc_insertion_point(field_list:dlserver.Model.intOptions)
  return intoptions_;
}

// repeated .dlserver.FloatOption floatOptions = 7;
inline int Model::floatoptions_size() const {
  return floatoptions_.size();
}
inline void Model::clear_floatoptions() {
  floatoptions_.Clear();
}
inline const ::dlserver::FloatOption& Model::floatoptions(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.Model.floatOptions)
  return floatoptions_.Get(index);
}
inline ::dlserver::FloatOption* Model::mutable_floatoptions(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.Model.floatOptions)
  return floatoptions_.Mutable(index);
}
inline ::dlserver::FloatOption* Model::add_floatoptions() {
  // @@protoc_insertion_point(field_add:dlserver.Model.floatOptions)
  return floatoptions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::FloatOption >*
Model::mutable_floatoptions() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.Model.floatOptions)
  return &floatoptions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::FloatOption >&
Model::floatoptions() const {
  // @@protoc_insertion_point(field_list:dlserver.Model.floatOptions)
  return floatoptions_;
}

// repeated .dlserver.StringOption stringOptions = 8;
inline int Model::stringoptions_size() const {
  return stringoptions_.size();
}
inline void Model::clear_stringoptions() {
  stringoptions_.Clear();
}
inline const ::dlserver::StringOption& Model::stringoptions(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.Model.stringOptions)
  return stringoptions_.Get(index);
}
inline ::dlserver::StringOption* Model::mutable_stringoptions(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.Model.stringOptions)
  return stringoptions_.Mutable(index);
}
inline ::dlserver::StringOption* Model::add_stringoptions() {
  // @@protoc_insertion_point(field_add:dlserver.Model.stringOptions)
  return stringoptions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::StringOption >*
Model::mutable_stringoptions() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.Model.stringOptions)
  return &stringoptions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::StringOption >&
Model::stringoptions() const {
  // @@protoc_insertion_point(field_list:dlserver.Model.stringOptions)
  return stringoptions_;
}

// repeated .dlserver.MultipleChoiceOption mcOptions = 9;
inline int Model::mcoptions_size() const {
  return mcoptions_.size();
}
inline void Model::clear_mcoptions() {
  mcoptions_.Clear();
}
inline const ::dlserver::MultipleChoiceOption& Model::mcoptions(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.Model.mcOptions)
  return mcoptions_.Get(index);
}
inline ::dlserver::MultipleChoiceOption* Model::mutable_mcoptions(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.Model.mcOptions)
  return mcoptions_.Mutable(index);
}
inline ::dlserver::MultipleChoiceOption* Model::add_mcoptions() {
  // @@protoc_insertion_point(field_add:dlserver.Model.mcOptions)
  return mcoptions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::MultipleChoiceOption >*
Model::mutable_mcoptions() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.Model.mcOptions)
  return &mcoptions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::MultipleChoiceOption >&
Model::mcoptions() const {
  // @@protoc_insertion_point(field_list:dlserver.Model.mcOptions)
  return mcoptions_;
}

// -------------------------------------------------------------------

// BoolOption

// required string name = 1;
inline bool BoolOption::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoolOption::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoolOption::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoolOption::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& BoolOption::name() const {
  // @@protoc_insertion_point(field_get:dlserver.BoolOption.name)
  return name_.GetNoArena();
}
inline void BoolOption::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.BoolOption.name)
}
#if LANG_CXX11
inline void BoolOption::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.BoolOption.name)
}
#endif
inline void BoolOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.BoolOption.name)
}
inline void BoolOption::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.BoolOption.name)
}
inline ::std::string* BoolOption::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dlserver.BoolOption.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BoolOption::release_name() {
  // @@protoc_insertion_point(field_release:dlserver.BoolOption.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BoolOption::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dlserver.BoolOption.name)
}

// required bool value = 2;
inline bool BoolOption::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoolOption::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoolOption::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoolOption::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool BoolOption::value() const {
  // @@protoc_insertion_point(field_get:dlserver.BoolOption.value)
  return value_;
}
inline void BoolOption::set_value(bool value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:dlserver.BoolOption.value)
}

// -------------------------------------------------------------------

// IntOption

// required string name = 1;
inline bool IntOption::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntOption::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntOption::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntOption::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& IntOption::name() const {
  // @@protoc_insertion_point(field_get:dlserver.IntOption.name)
  return name_.GetNoArena();
}
inline void IntOption::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.IntOption.name)
}
#if LANG_CXX11
inline void IntOption::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.IntOption.name)
}
#endif
inline void IntOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.IntOption.name)
}
inline void IntOption::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.IntOption.name)
}
inline ::std::string* IntOption::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dlserver.IntOption.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IntOption::release_name() {
  // @@protoc_insertion_point(field_release:dlserver.IntOption.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IntOption::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dlserver.IntOption.name)
}

// required int32 value = 2;
inline bool IntOption::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntOption::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntOption::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntOption::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 IntOption::value() const {
  // @@protoc_insertion_point(field_get:dlserver.IntOption.value)
  return value_;
}
inline void IntOption::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:dlserver.IntOption.value)
}

// -------------------------------------------------------------------

// FloatOption

// required string name = 1;
inline bool FloatOption::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatOption::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatOption::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatOption::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& FloatOption::name() const {
  // @@protoc_insertion_point(field_get:dlserver.FloatOption.name)
  return name_.GetNoArena();
}
inline void FloatOption::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.FloatOption.name)
}
#if LANG_CXX11
inline void FloatOption::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.FloatOption.name)
}
#endif
inline void FloatOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.FloatOption.name)
}
inline void FloatOption::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.FloatOption.name)
}
inline ::std::string* FloatOption::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dlserver.FloatOption.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FloatOption::release_name() {
  // @@protoc_insertion_point(field_release:dlserver.FloatOption.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FloatOption::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dlserver.FloatOption.name)
}

// required float value = 2;
inline bool FloatOption::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatOption::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloatOption::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloatOption::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float FloatOption::value() const {
  // @@protoc_insertion_point(field_get:dlserver.FloatOption.value)
  return value_;
}
inline void FloatOption::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:dlserver.FloatOption.value)
}

// -------------------------------------------------------------------

// StringOption

// required string name = 1;
inline bool StringOption::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringOption::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringOption::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringOption::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& StringOption::name() const {
  // @@protoc_insertion_point(field_get:dlserver.StringOption.name)
  return name_.GetNoArena();
}
inline void StringOption::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.StringOption.name)
}
#if LANG_CXX11
inline void StringOption::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.StringOption.name)
}
#endif
inline void StringOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.StringOption.name)
}
inline void StringOption::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.StringOption.name)
}
inline ::std::string* StringOption::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dlserver.StringOption.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringOption::release_name() {
  // @@protoc_insertion_point(field_release:dlserver.StringOption.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringOption::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dlserver.StringOption.name)
}

// required string value = 2;
inline bool StringOption::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringOption::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringOption::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringOption::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& StringOption::value() const {
  // @@protoc_insertion_point(field_get:dlserver.StringOption.value)
  return value_.GetNoArena();
}
inline void StringOption::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.StringOption.value)
}
#if LANG_CXX11
inline void StringOption::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.StringOption.value)
}
#endif
inline void StringOption::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.StringOption.value)
}
inline void StringOption::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.StringOption.value)
}
inline ::std::string* StringOption::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:dlserver.StringOption.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringOption::release_value() {
  // @@protoc_insertion_point(field_release:dlserver.StringOption.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringOption::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:dlserver.StringOption.value)
}

// -------------------------------------------------------------------

// MultipleChoiceOption

// required string name = 1;
inline bool MultipleChoiceOption::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultipleChoiceOption::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultipleChoiceOption::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultipleChoiceOption::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MultipleChoiceOption::name() const {
  // @@protoc_insertion_point(field_get:dlserver.MultipleChoiceOption.name)
  return name_.GetNoArena();
}
inline void MultipleChoiceOption::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.MultipleChoiceOption.name)
}
#if LANG_CXX11
inline void MultipleChoiceOption::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.MultipleChoiceOption.name)
}
#endif
inline void MultipleChoiceOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.MultipleChoiceOption.name)
}
inline void MultipleChoiceOption::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.MultipleChoiceOption.name)
}
inline ::std::string* MultipleChoiceOption::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dlserver.MultipleChoiceOption.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipleChoiceOption::release_name() {
  // @@protoc_insertion_point(field_release:dlserver.MultipleChoiceOption.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipleChoiceOption::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dlserver.MultipleChoiceOption.name)
}

// required string value = 2;
inline bool MultipleChoiceOption::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultipleChoiceOption::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultipleChoiceOption::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultipleChoiceOption::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& MultipleChoiceOption::value() const {
  // @@protoc_insertion_point(field_get:dlserver.MultipleChoiceOption.value)
  return value_.GetNoArena();
}
inline void MultipleChoiceOption::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.MultipleChoiceOption.value)
}
#if LANG_CXX11
inline void MultipleChoiceOption::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.MultipleChoiceOption.value)
}
#endif
inline void MultipleChoiceOption::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.MultipleChoiceOption.value)
}
inline void MultipleChoiceOption::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.MultipleChoiceOption.value)
}
inline ::std::string* MultipleChoiceOption::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:dlserver.MultipleChoiceOption.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MultipleChoiceOption::release_value() {
  // @@protoc_insertion_point(field_release:dlserver.MultipleChoiceOption.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MultipleChoiceOption::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:dlserver.MultipleChoiceOption.value)
}

// repeated string choices = 3;
inline int MultipleChoiceOption::choices_size() const {
  return choices_.size();
}
inline void MultipleChoiceOption::clear_choices() {
  choices_.Clear();
}
inline const ::std::string& MultipleChoiceOption::choices(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.MultipleChoiceOption.choices)
  return choices_.Get(index);
}
inline ::std::string* MultipleChoiceOption::mutable_choices(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.MultipleChoiceOption.choices)
  return choices_.Mutable(index);
}
inline void MultipleChoiceOption::set_choices(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:dlserver.MultipleChoiceOption.choices)
  choices_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MultipleChoiceOption::set_choices(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:dlserver.MultipleChoiceOption.choices)
  choices_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MultipleChoiceOption::set_choices(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  choices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dlserver.MultipleChoiceOption.choices)
}
inline void MultipleChoiceOption::set_choices(int index, const char* value, size_t size) {
  choices_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dlserver.MultipleChoiceOption.choices)
}
inline ::std::string* MultipleChoiceOption::add_choices() {
  // @@protoc_insertion_point(field_add_mutable:dlserver.MultipleChoiceOption.choices)
  return choices_.Add();
}
inline void MultipleChoiceOption::add_choices(const ::std::string& value) {
  choices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dlserver.MultipleChoiceOption.choices)
}
#if LANG_CXX11
inline void MultipleChoiceOption::add_choices(::std::string&& value) {
  choices_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dlserver.MultipleChoiceOption.choices)
}
#endif
inline void MultipleChoiceOption::add_choices(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  choices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dlserver.MultipleChoiceOption.choices)
}
inline void MultipleChoiceOption::add_choices(const char* value, size_t size) {
  choices_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dlserver.MultipleChoiceOption.choices)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MultipleChoiceOption::choices() const {
  // @@protoc_insertion_point(field_list:dlserver.MultipleChoiceOption.choices)
  return choices_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MultipleChoiceOption::mutable_choices() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.MultipleChoiceOption.choices)
  return &choices_;
}

// -------------------------------------------------------------------

// ImagePrototype

// required string name = 1;
inline bool ImagePrototype::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImagePrototype::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImagePrototype::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImagePrototype::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ImagePrototype::name() const {
  // @@protoc_insertion_point(field_get:dlserver.ImagePrototype.name)
  return name_.GetNoArena();
}
inline void ImagePrototype::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.ImagePrototype.name)
}
#if LANG_CXX11
inline void ImagePrototype::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.ImagePrototype.name)
}
#endif
inline void ImagePrototype::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.ImagePrototype.name)
}
inline void ImagePrototype::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.ImagePrototype.name)
}
inline ::std::string* ImagePrototype::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:dlserver.ImagePrototype.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImagePrototype::release_name() {
  // @@protoc_insertion_point(field_release:dlserver.ImagePrototype.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImagePrototype::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dlserver.ImagePrototype.name)
}

// required int32 channels = 2;
inline bool ImagePrototype::has_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImagePrototype::set_has_channels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImagePrototype::clear_has_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImagePrototype::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 ImagePrototype::channels() const {
  // @@protoc_insertion_point(field_get:dlserver.ImagePrototype.channels)
  return channels_;
}
inline void ImagePrototype::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
  // @@protoc_insertion_point(field_set:dlserver.ImagePrototype.channels)
}

// -------------------------------------------------------------------

// Error

// required string msg = 1;
inline bool Error::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
inline const ::std::string& Error::msg() const {
  // @@protoc_insertion_point(field_get:dlserver.Error.msg)
  return msg_.GetNoArena();
}
inline void Error::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.Error.msg)
}
#if LANG_CXX11
inline void Error::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.Error.msg)
}
#endif
inline void Error::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.Error.msg)
}
inline void Error::set_msg(const char* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.Error.msg)
}
inline ::std::string* Error::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:dlserver.Error.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_msg() {
  // @@protoc_insertion_point(field_release:dlserver.Error.msg)
  clear_has_msg();
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:dlserver.Error.msg)
}

// -------------------------------------------------------------------

// RequestInference

// required .dlserver.Model model = 1;
inline bool RequestInference::has_model() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestInference::set_has_model() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestInference::clear_has_model() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestInference::clear_model() {
  if (model_ != NULL) model_->Clear();
  clear_has_model();
}
inline const ::dlserver::Model& RequestInference::model() const {
  const ::dlserver::Model* p = model_;
  // @@protoc_insertion_point(field_get:dlserver.RequestInference.model)
  return p != NULL ? *p : *reinterpret_cast<const ::dlserver::Model*>(
      &::dlserver::_Model_default_instance_);
}
inline ::dlserver::Model* RequestInference::release_model() {
  // @@protoc_insertion_point(field_release:dlserver.RequestInference.model)
  clear_has_model();
  ::dlserver::Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline ::dlserver::Model* RequestInference::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    model_ = new ::dlserver::Model;
  }
  // @@protoc_insertion_point(field_mutable:dlserver.RequestInference.model)
  return model_;
}
inline void RequestInference::set_allocated_model(::dlserver::Model* model) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete model_;
  }
  if (model) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      model = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    set_has_model();
  } else {
    clear_has_model();
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:dlserver.RequestInference.model)
}

// repeated .dlserver.Image image = 2;
inline int RequestInference::image_size() const {
  return image_.size();
}
inline void RequestInference::clear_image() {
  image_.Clear();
}
inline const ::dlserver::Image& RequestInference::image(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.RequestInference.image)
  return image_.Get(index);
}
inline ::dlserver::Image* RequestInference::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.RequestInference.image)
  return image_.Mutable(index);
}
inline ::dlserver::Image* RequestInference::add_image() {
  // @@protoc_insertion_point(field_add:dlserver.RequestInference.image)
  return image_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::Image >*
RequestInference::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.RequestInference.image)
  return &image_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::Image >&
RequestInference::image() const {
  // @@protoc_insertion_point(field_list:dlserver.RequestInference.image)
  return image_;
}

// -------------------------------------------------------------------

// RespondInference

// required int32 numImages = 1;
inline bool RespondInference::has_numimages() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespondInference::set_has_numimages() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespondInference::clear_has_numimages() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespondInference::clear_numimages() {
  numimages_ = 0;
  clear_has_numimages();
}
inline ::google::protobuf::int32 RespondInference::numimages() const {
  // @@protoc_insertion_point(field_get:dlserver.RespondInference.numImages)
  return numimages_;
}
inline void RespondInference::set_numimages(::google::protobuf::int32 value) {
  set_has_numimages();
  numimages_ = value;
  // @@protoc_insertion_point(field_set:dlserver.RespondInference.numImages)
}

// repeated .dlserver.Image image = 2;
inline int RespondInference::image_size() const {
  return image_.size();
}
inline void RespondInference::clear_image() {
  image_.Clear();
}
inline const ::dlserver::Image& RespondInference::image(int index) const {
  // @@protoc_insertion_point(field_get:dlserver.RespondInference.image)
  return image_.Get(index);
}
inline ::dlserver::Image* RespondInference::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:dlserver.RespondInference.image)
  return image_.Mutable(index);
}
inline ::dlserver::Image* RespondInference::add_image() {
  // @@protoc_insertion_point(field_add:dlserver.RespondInference.image)
  return image_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::dlserver::Image >*
RespondInference::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:dlserver.RespondInference.image)
  return &image_;
}
inline const ::google::protobuf::RepeatedPtrField< ::dlserver::Image >&
RespondInference::image() const {
  // @@protoc_insertion_point(field_list:dlserver.RespondInference.image)
  return image_;
}

// -------------------------------------------------------------------

// Image

// required int32 width = 1;
inline bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Image::width() const {
  // @@protoc_insertion_point(field_get:dlserver.Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:dlserver.Image.width)
}

// required int32 height = 2;
inline bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Image::height() const {
  // @@protoc_insertion_point(field_get:dlserver.Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:dlserver.Image.height)
}

// required int32 channels = 3;
inline bool Image::has_channels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_channels() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_channels() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_channels() {
  channels_ = 0;
  clear_has_channels();
}
inline ::google::protobuf::int32 Image::channels() const {
  // @@protoc_insertion_point(field_get:dlserver.Image.channels)
  return channels_;
}
inline void Image::set_channels(::google::protobuf::int32 value) {
  set_has_channels();
  channels_ = value;
  // @@protoc_insertion_point(field_set:dlserver.Image.channels)
}

// required bytes image = 4;
inline bool Image::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& Image::image() const {
  // @@protoc_insertion_point(field_get:dlserver.Image.image)
  return image_.GetNoArena();
}
inline void Image::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dlserver.Image.image)
}
#if LANG_CXX11
inline void Image::set_image(::std::string&& value) {
  set_has_image();
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dlserver.Image.image)
}
#endif
inline void Image::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dlserver.Image.image)
}
inline void Image::set_image(const void* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dlserver.Image.image)
}
inline ::std::string* Image::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:dlserver.Image.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_image() {
  // @@protoc_insertion_point(field_release:dlserver.Image.image)
  clear_has_image();
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:dlserver.Image.image)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dlserver

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
